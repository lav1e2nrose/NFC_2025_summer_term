C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 14:42:14 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c COMPACT OPTIMIZE(8,SPEED) BROWSE INCDIR(C:\Program Files\Keil_v5\C51
                    -\INC) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "oled.h"
   2          #include "utils.h"
   3          #include "PN532.h"
   4          #include "AT24C02.h"
   5          #include "menu.h"
   6          
   7          typedef enum mode // æ¨¡å¼æ¥æ ‡è¯†å„ä¸ªé¡µé¢
   8          {
   9              MENU, PN532, BT, EEPROM, PN532READ, PN532WRITE, PN532CARD, PN532P2P, BTTD, DATA
  10          } MODE;
  11          
  12          sbit BUZZER = P2^7; // èœ‚é¸£å™¨
  13          
  14          MODE mode = MENU, prev_mode;
  15          
  16          extern u8 rec_str[], prt_str[]; // ç”¨äºä¸²å£æ•°æ®æ¥æ”¶
  17          extern u32 rec_cnt; // ä¸²å£æ•°æ®é‡è®¡æ•°
  18          
  19          // å·²çŸ¥å¡UIDå’Œå¯¹åº”å­¦å·
  20          code u8 KNOWN_UID1[] = "4EDA9C04";
  21          code u8 KNOWN_UID2[] = "87654321";
  22          code u8 KNOWN_STUID1[] = "3230105625";
  23          code u8 KNOWN_STUID2[] = "3230105626";
  24          code u8 UNKNOWN_STUID[] = "0000000000";
  25          
  26          void beep() // èœ‚é¸£ 0.5 ç§’
  27          {
  28   1        BUZZER = 0;
  29   1        delay_ms(500);
  30   1        BUZZER = 1;
  31   1      }
  32          
  33          void UartInit(void)   // 9600bps @ 11.0592MHz
  34          {
  35   1        PCON |= 0x80;   // ä½¿èƒ½æ³¢ç‰¹ç‡å€é€Ÿä½ SMOD
  36   1        SCON = 0x50;    // 8 ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
  37   1        TMOD &= 0x0F;   // æ¸…é™¤å®šæ—¶å™¨ 1 æ¨¡å¼ä½
  38   1        TMOD |= 0x20;   // è®¾å®šå®šæ—¶å™¨ 1 ä¸º 8 ä½è‡ªåŠ¨é‡è£…æ–¹å¼
  39   1        TL1 = 0xFA;   // è®¾å®šå®šæ—¶åˆå€¼
  40   1        TH1 = 0xFA;   // è®¾å®šå®šæ—¶å™¨é‡è£…å€¼
  41   1        ET1 = 0;    // ç¦æ­¢å®šæ—¶å™¨ 1 ä¸­æ–­
  42   1        TR1 = 1;    // å¯åŠ¨å®šæ—¶å™¨ 1
  43   1        EA = 1;
  44   1        ES = 1;
  45   1      }
  46          
  47          // æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰
  48          bit compareUID(u8 *uid1, u8 *uid2)
  49          {
  50   1          u8 i;
  51   1          for(i = 0; i < 8; i++) {
  52   2              if(uid1[i] != uid2[i])
  53   2                  return 0;
  54   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 14:42:14 PAGE 2   

  55   1          return 1;
  56   1      }
  57          
  58          void Usart() interrupt 4 // ä¸²å£ä¸­æ–­
  59          {
  60   1        EA = 0;
  61   1        rec_str[rec_cnt++] = SBUF;
  62   1        RI = 0; // æ¸…é™¤æ¥æ”¶ä¸­æ–­æ ‡å¿—ä½
  63   1        EA = 1;
  64   1      }
  65          
  66          void display() // è´Ÿè´£è°ƒæ•´æ˜¾ç¤ºå†…å®¹ä¸ä¸šåŠ¡é€»è¾‘
  67          {
  68   1          u8 *title, idata list[4][16], idata buffer[14] = {0}, i, idata cards[3][11], length, pos = 0, id[9], s
             -tuid[11], data_pos;
  69   1        MODE mode_list[5];
  70   1        SELECT select;
  71   1        CARD idata card;
  72   1        switch (mode)
  73   1        {
  74   2          case PN532READ: case PN532WRITE: case PN532CARD: case PN532P2P: case BTTD: case DATA:
  75   2          {
  76   3            if (check_lu())
  77   3            {
  78   4              prev_mode = mode;
  79   4              mode = MENU;
  80   4              OLED_Clear();
  81   4            }
  82   3            break;
  83   3          }
  84   2        }
  85   1          switch(mode)
  86   1          {
  87   2              case MENU: // æ˜¾ç¤ºèœå•
  88   2              {
  89   3                  title = "MENU";
  90   3            strcpy(list[0], "PN532         ");
  91   3            strcpy(list[1], "BlueTooth     ");
  92   3            strcpy(list[2], "EEPROM        ");
  93   3            length = 3;
  94   3            select = YES;
  95   3            break;
  96   3              }
  97   2          case PN532: // PN532 é€‰é¡¹
  98   2              {
  99   3                  title = "PN532";
 100   3            strcpy(list[0], "Read          ");
 101   3            strcpy(list[1], "Write         ");
 102   3            strcpy(list[2], "Card          ");
 103   3            strcpy(list[3], "P2P           ");
 104   3            length = 4;
 105   3            select = YES;
 106   3            break;
 107   3              }
 108   2          case BT: // è“ç‰™é€‰é¡¹
 109   2              {
 110   3                  title = "BlueTooth";
 111   3            strcpy(list[0], "Transfer Data ");
 112   3            length = 1;
 113   3            select = YES;
 114   3            break;
 115   3              }
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 14:42:14 PAGE 3   

 116   2          case PN532READ: // è¯»å¡ç•Œé¢
 117   2              {
 118   3                  title = "PN532 - Read";
 119   3            length = 3;
 120   3            select = NO;
 121   3      
 122   3            rec_cnt = 0;
 123   3            PN532_findUID(); // å…ˆæ¸²æŸ“è¯»å¡ä¸­ç•Œé¢ï¼ŒåŒæ—¶å‘é€å¯»å¡æŒ‡ä»¤
 124   3            strcpy(list[0], "Reading...");
 125   3            strcpy(list[1], "MENU         UP");
 126   3            strcpy(list[2], "BACK       DOWN");
 127   3            display_list(title, list, length, pos, select);
 128   3      
 129   3            while (1) // è¿›å…¥æ­»å¾ªç¯ç­‰å¾…è¯»åˆ°å¡
 130   3            {
 131   4              if (rec_cnt > 15)
 132   4              {
 133   5                rec_cnt = 0;
 134   5                beep(); // èœ‚é¸£æç¤º
 135   5                trans_uid();
 136   5                strncpy(buffer, prt_str, 8); // å‡†å¤‡æ˜¾ç¤ºå¡å·
 137   5                strcpy(card.id, buffer);
 138   5                strcpy(list[0], strcat(buffer, "  "));
 139   5                strcpy(list[1], "SAVE            ");
 140   5                strcpy(list[2], "BACK            ");
 141   5                display_list(title, list, length, pos, select);
 142   5                while (1) // è¿›å…¥æ­»å¾ªç¯ç­‰å¾…ä¿å­˜ / ä¸ä¿å­˜
 143   5                {
 144   6                  if (check_lu()) // æŒ‰ä¸‹ä¿å­˜æŒ‰é’®çš„é€»è¾‘
 145   6                  {
 146   7                    // æ ¹æ®UIDåŒ¹é…å­¦å·
 147   7                    if(compareUID(card.id, KNOWN_UID1)) {
 148   8                      strcpy(card.stuid, KNOWN_STUID1);
 149   8                    } else if(compareUID(card.id, KNOWN_UID2)) {
 150   8                      strcpy(card.stuid, KNOWN_STUID2);
 151   8                    } else {
 152   8                      strcpy(card.stuid, UNKNOWN_STUID); // æœªçŸ¥å¡è®¾ä¸º0000000000
 153   8                    }
 154   7                    data_pos = AT24C02_ReadByte(0xFF); // ä» EEPROM å¤„è¯»å–ä¿å­˜å¡çš„ä½ç½®ï¼ˆè®¾å®šä¸º 3 ä¸ªä½ç½
             -®ï¼‰
 155   7                    delay_ms(50);
 156   7                    AT24C02_WriteCard(card, data_pos); // å†™å¡è¿› EEPROMï¼ŒåŒ…æ‹¬ ID å’Œå­¦å·
 157   7                    data_pos = (data_pos == 2)? 0: (data_pos + 1);
 158   7                    delay_ms(50);
 159   7                    AT24C02_WriteByte(0xFF, data_pos); // å†™ä¿å­˜ä½ç½®å…¥ EEPROM
 160   7                    mode = MENU; // é‡æ–°æ¸²æŸ“èœå•
 161   7                    title = "MENU";
 162   7                    strcpy(list[0], "PN532         ");
 163   7                    strcpy(list[1], "BlueTooth     ");
 164   7                    strcpy(list[2], "EEPROM        ");
 165   7                    select = YES;
 166   7                    OLED_Clear();
 167   7                    break;
 168   7                  }
 169   6                  if (check_ld())
 170   6                  {
 171   7                    mode = MENU;
 172   7                    title = "MENU";
 173   7                    strcpy(list[0], "PN532         ");
 174   7                    strcpy(list[1], "BlueTooth     ");
 175   7                    strcpy(list[2], "EEPROM        ");
 176   7                    select = YES;
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 14:42:14 PAGE 4   

 177   7                    OLED_Clear();
 178   7                    break;
 179   7                  }
 180   6                }
 181   5                break;
 182   5              }
 183   4            }
 184   3            break;
 185   3              }
 186   2          case PN532WRITE:
 187   2              {
 188   3                  title = "PN532 - Write";
 189   3            strcpy(list[0], "Writing...");
 190   3            strcpy(list[1], "MENU         UP");
 191   3            strcpy(list[2], "BACK       DOWN");
 192   3            length = 3;
 193   3            select = NO;
 194   3            break;
 195   3              }
 196   2          case PN532CARD:
 197   2              {
 198   3                  title = "PN532 - Card";
 199   3            strcpy(list[0], "Simulating...");
 200   3            strcpy(list[1], "MENU         UP");
 201   3            strcpy(list[2], "BACK       DOWN");
 202   3            length = 3;
 203   3            select = NO;
 204   3            break;
 205   3              }
 206   2          case PN532P2P:
 207   2              {
 208   3                  title = "PN532 - P2P";
 209   3            strcpy(list[0], "Connecting...");
 210   3            strcpy(list[1], "MENU         UP");
 211   3            strcpy(list[2], "BACK       DOWN");
 212   3            length = 3;
 213   3            select = NO;
 214   3            break;
 215   3              }
 216   2          case BTTD:
 217   2              {
 218   3                  title = "BlueTooth - TD";
 219   3            strcpy(list[0], "Transferring...");
 220   3            strcpy(list[1], "MENU         UP");
 221   3            strcpy(list[2], "BACK       DOWN");
 222   3            length = 3;
 223   3            select = NO;
 224   3            break;
 225   3              }
 226   2          case EEPROM:
 227   2          {
 228   3            title = "EEPROM";
 229   3            AT24C02_ReadAll(cards); // ä» EEPROM è¯»å–æ‰€æœ‰å¡å·
 230   3            for (i = 0; i < 3; i++)
 231   3            {
 232   4              strcpy(list[i], cards[i]);
 233   4            }
 234   3            length = i;
 235   3            select = YES;
 236   3            break;
 237   3          }
 238   2          case DATA:
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 14:42:14 PAGE 5   

 239   2          {
 240   3            strcpy(title, id);
 241   3            strcpy(list[0], stuid);
 242   3            strcpy(list[1], "MENU         UP");
 243   3            strcpy(list[2], "BACK       DOWN");
 244   3            length = 3;
 245   3            select = NO;
 246   3            break;
 247   3          }
 248   2          }
 249   1        switch (mode)
 250   1        {
 251   2          case MENU: case PN532: case BT: case EEPROM: // å¯é€‰èœå•çš„æ¸²æŸ“é€»è¾‘
 252   2          {
 253   3            while (1)
 254   3            {
 255   4              // é€šè¿‡æŒ‰é”®è°ƒæ•´é€‰ä¸­æ 
 256   4              pos = (check_ru() && pos > 0)? (pos - 1): pos;
 257   4              pos = (check_rd() && pos < length - 1)? (pos + 1): pos;
 258   4              display_list(title, list, length, pos, select);
 259   4              if (check_ld())
 260   4              {
 261   5                mode = prev_mode;
 262   5                OLED_Clear();
 263   5                break;
 264   5              }
 265   4              if (check_lu()) // é€‰ä¸­çš„é€»è¾‘
 266   4              {
 267   5                switch (mode)
 268   5                {
 269   6                  case MENU:
 270   6                  {
 271   7                    mode_list[0] = PN532;
 272   7                    mode_list[1] = BT;
 273   7                    mode_list[2] = EEPROM;
 274   7                    mode = mode_list[pos];
 275   7                    OLED_Clear();
 276   7                    break;
 277   7                  }
 278   6                  case PN532:
 279   6                  {
 280   7                    mode_list[0] = PN532READ;
 281   7                    mode_list[1] = PN532WRITE;
 282   7                    mode_list[2] = PN532CARD;
 283   7                    mode_list[3] = PN532P2P;
 284   7                    mode = mode_list[pos];
 285   7                    OLED_Clear();
 286   7                    break;
 287   7                  }
 288   6                  case BT:
 289   6                  {
 290   7                    mode_list[0] = BTTD;
 291   7                    mode = mode_list[pos];
 292   7                    OLED_Clear();
 293   7                    break;
 294   7                  }
 295   6                  case EEPROM: // è¯»å‡ºå¡çš„æ•°æ®
 296   6                  {
 297   7                    strcpy(id, cards[pos]);
 298   7                    AT24C02_ReadCard_pos(pos, &card);
 299   7                    strcpy(stuid, card.stuid);
 300   7                    mode = DATA;
C51 COMPILER V9.60.7.0   MAIN                                                              09/05/2025 14:42:14 PAGE 6   

 301   7                    OLED_Clear();
 302   7                    break;
 303   7                  }
 304   6                }
 305   5                break;
 306   5              }
 307   4            }
 308   3            break;
 309   3          }
 310   2          default:
 311   2          {
 312   3            display_list(title, list, length, pos, select);
 313   3          }
 314   2        }
 315   1      }
 316          
 317          void main()
 318          {
 319   1        CARD Data = {0};
 320   1          OLED_Init();      // åˆå§‹åŒ– OLED
 321   1          OLED_Clear();
 322   1        PN532_Init();
 323   1        delay_ms(100);
 324   1        UartInit();
 325   1        memset(rec_str, 0, sizeof(rec_str));
*** WARNING C198 IN LINE 325 OF main.c: sizeof returns zero
 326   1        rec_cnt = 0;
 327   1        while (1)
 328   1        {
 329   2          BUZZER = (check_sw3())? ~BUZZER: BUZZER;
 330   2          display();
 331   2        }
 332   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1661    ----
   CONSTANT SIZE    =    435    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      2      35
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----     155
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
