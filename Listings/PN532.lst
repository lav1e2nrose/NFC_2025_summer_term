C51 COMPILER V9.60.7.0   PN532                                                             08/29/2025 17:38:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PN532
OBJECT MODULE PLACED IN .\Objects\PN532.obj
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE PN532.c COMPACT OPTIMIZE(8,SPEED) BROWSE INCDIR(C:\Program Files\Keil_v5\C5
                    -1\INC) DEBUG OBJECTEXTEND PRINT(.\Listings\PN532.lst) TABS(2) OBJECT(.\Objects\PN532.obj)

line level    source

   1          #include "PN532.h"
   2          #include <INTRINS.H>
   3          #include <string.h>
   4          
   5          u8 rec_str[40]; // 串口接收的数据
   6          u32 rec_cnt;    // 串口接收个数
   7          u8 prt_str[16];
   8          
   9          sbit tx = P3^1;
  10          
  11          // 发送单个字节信号
  12          void send_Bytee(u8 ch)
  13          {
  14   1        SBUF = ch;
  15   1        while (!TI);       // 等待发送数据完成
  16   1        TI = 0;          // 清除发送完成标志位 
  17   1      }
  18          
  19          void send_Byte(u8 ch)   // 使用软件模拟 115200 波特率，_nop_() 个数手动调整
  20          {
  21   1        tx = 1;
  22   1        _nop_(); _nop_(); _nop_(); _nop_(); _nop_();
  23   1          tx = 0;
  24   1        _nop_(); _nop_(); _nop_(); _nop_();
  25   1        tx = ch & 0x01;
  26   1          ch = ch >> 1;
  27   1        _nop_();
  28   1        tx = ch & 0x01;
  29   1          ch = ch >> 1;
  30   1        _nop_();
  31   1        tx = ch & 0x01;
  32   1          ch = ch >> 1;
  33   1        _nop_();
  34   1        tx = ch & 0x01;
  35   1          ch = ch >> 1;
  36   1        _nop_();
  37   1        tx = ch & 0x01;
  38   1          ch = ch >> 1;
  39   1        _nop_();
  40   1        tx = ch & 0x01;
  41   1          ch = ch >> 1;
  42   1        _nop_();
  43   1        tx = ch & 0x01;
  44   1          ch = ch >> 1;
  45   1        _nop_();
  46   1        tx = ch & 0x01;
  47   1          ch = ch >> 1;
  48   1        _nop_(); _nop_(); _nop_(); _nop_(); _nop_(); _nop_(); _nop_();
  49   1        tx = 1;
  50   1      }
  51          
  52          void send_Command(u8* command, u8 length) // 使用软件模拟 115200 波特率发送数据
  53          {
  54   1          u8 i;
C51 COMPILER V9.60.7.0   PN532                                                             08/29/2025 17:38:19 PAGE 2   

  55   1          for (i = 0; i < length; i++)
  56   1          {
  57   2              send_Byte(command[i]);
  58   2          }
  59   1      }
  60          
  61          void send_Commandd(u8* command, u8 length) // 使用硬件串口 9600 波特率发送数据
  62          {
  63   1          u8 i;
  64   1          for (i = 0; i < length; i++)
  65   1          {
  66   2              send_Bytee(command[i]);
  67   2          }
  68   1      }
  69          
  70          void PN532_Init()
  71          {
  72   1          u8 command[24] = {0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x00, 0xFF, 0x03, 0xFD, 0xD4, 0x14, 0x01, 0x17, 0x00};
  73   1        u8 baud[10] = {0x00, 0x00, 0xFF, 0x03, 0xFD, 0xD4, 0x10, 0x00, 0x1C, 0x00};
  74   1        send_Command(command, 24); // 激活
  75   1        delay_ms(100);
  76   1          send_Command(baud, 10); // 调整波特率，需要发两遍
  77   1        delay_ms(1000);
  78   1        send_Command(baud, 10);
  79   1      }
  80          
  81          void PN532_findUID()
  82          {
  83   1          u8 command[11] = {0x00, 0x00, 0xFF, 0x04, 0xFC, 0xD4, 0x4A, 0x02, 0x00, 0xE0, 0x00};
  84   1        memset(rec_str, 0, sizeof(rec_str));
  85   1        send_Commandd(command, 11); // 寻卡
  86   1        rec_cnt = 0;
  87   1      }
  88          
  89          void trans_uid() // 将读到的 16 进制 ID 转换为字符串
  90          { 
  91   1        u8 i;
  92   1        for(i = 0; i < 4; i++)
  93   1        {
  94   2          prt_str[2 * i] = rec_str[i + 2] / 16;
  95   2          prt_str[2 * i + 1] = rec_str[i + 2] % 16;
  96   2        }
  97   1        for(i = 0; i < 8; i++)
  98   1        {
  99   2          (prt_str[i] > 9)? (prt_str[i] += 0x37): (prt_str[i] += 0x30);
 100   2        }
 101   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    380    ----
   CONSTANT SIZE    =     45    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     58      51
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
